{"ast":null,"code":"// array in local storage for registered users\nlet users = JSON.parse(localStorage.getItem(\"users\")) || [];\nexport function configureFakeBackend() {\n  let realFetch = window.fetch;\n\n  window.fetch = function (url, opts) {\n    return new Promise((resolve, reject) => {\n      // wrap in timeout to simulate server api call\n      setTimeout(() => {\n        // authenticate\n        if (url.endsWith(\"/users/authenticate\") && opts.method === \"POST\") {\n          // get parameters from post request\n          let params = JSON.parse(opts.body); // find if any user matches login credentials\n\n          let filteredUsers = users.filter(user => {\n            return user.username === params.username && user.password === params.password;\n          });\n\n          if (filteredUsers.length) {\n            // if login details are valid return user details and fake jwt token\n            let user = filteredUsers[0];\n            let responseJson = {\n              id: user.id,\n              username: user.username,\n              firstName: user.firstName,\n              lastName: user.lastName,\n              token: \"fake-jwt-token\"\n            };\n            resolve({\n              ok: true,\n              text: () => Promise.resolve(JSON.stringify(responseJson))\n            });\n          } else {\n            // else return error\n            reject(\"Username or password is incorrect\");\n          }\n\n          return;\n        } // get users\n\n\n        if (url.endsWith(\"/users\") && opts.method === \"GET\") {\n          // check for fake auth token in header and return users if valid, this security is implemented server side in a real application\n          if (opts.headers && opts.headers.Authorization === \"Bearer fake-jwt-token\") {\n            resolve({\n              ok: true,\n              text: () => Promise.resolve(JSON.stringify(users))\n            });\n          } else {\n            // return 401 not authorised if token is null or invalid\n            reject(\"Unauthorised\");\n          }\n\n          return;\n        } // get user by id\n\n\n        if (url.match(/\\/users\\/\\d+$/) && opts.method === \"GET\") {\n          // check for fake auth token in header and return user if valid, this security is implemented server side in a real application\n          if (opts.headers && opts.headers.Authorization === \"Bearer fake-jwt-token\") {\n            // find user by id in users array\n            let urlParts = url.split(\"/\");\n            let id = parseInt(urlParts[urlParts.length - 1]);\n            let matchedUsers = users.filter(user => {\n              return user.id === id;\n            });\n            let user = matchedUsers.length ? matchedUsers[0] : null; // respond 200 OK with user\n\n            resolve({\n              ok: true,\n              text: () => JSON.stringify(user)\n            });\n          } else {\n            // return 401 not authorised if token is null or invalid\n            reject(\"Unauthorised\");\n          }\n\n          return;\n        } // register user\n\n\n        if (url.endsWith(\"/users/register\") && opts.method === \"POST\") {\n          // get new user object from post body\n          let newUser = JSON.parse(opts.body); // validation\n\n          let duplicateUser = users.filter(user => {\n            return user.username === newUser.username;\n          }).length;\n\n          if (duplicateUser) {\n            reject('Username \"' + newUser.username + '\" is already taken');\n            return;\n          } // save new user\n\n\n          newUser.id = users.length ? Math.max(...users.map(user => user.id)) + 1 : 1;\n          users.push(newUser);\n          localStorage.setItem(\"users\", JSON.stringify(users)); // respond 200 OK\n\n          resolve({\n            ok: true,\n            text: () => Promise.resolve()\n          });\n          return;\n        } // delete user\n\n\n        if (url.match(/\\/users\\/\\d+$/) && opts.method === \"DELETE\") {\n          // check for fake auth token in header and return user if valid, this security is implemented server side in a real application\n          if (opts.headers && opts.headers.Authorization === \"Bearer fake-jwt-token\") {\n            // find user by id in users array\n            let urlParts = url.split(\"/\");\n            let id = parseInt(urlParts[urlParts.length - 1]);\n\n            for (let i = 0; i < users.length; i++) {\n              let user = users[i];\n\n              if (user.id === id) {\n                // delete user\n                users.splice(i, 1);\n                localStorage.setItem(\"users\", JSON.stringify(users));\n                break;\n              }\n            } // respond 200 OK\n\n\n            resolve({\n              ok: true,\n              text: () => Promise.resolve()\n            });\n          } else {\n            // return 401 not authorised if token is null or invalid\n            reject(\"Unauthorised\");\n          }\n\n          return;\n        } // pass through any requests not handled above\n\n\n        realFetch(url, opts).then(response => resolve(response));\n      }, 500);\n    });\n  };\n}","map":{"version":3,"sources":["D:/Materi Kuliah/SEM 7/Magang/ReactTutorial/user_registration/src/_helpers/fake-backend.js"],"names":["users","JSON","parse","localStorage","getItem","configureFakeBackend","realFetch","window","fetch","url","opts","Promise","resolve","reject","setTimeout","endsWith","method","params","body","filteredUsers","filter","user","username","password","length","responseJson","id","firstName","lastName","token","ok","text","stringify","headers","Authorization","match","urlParts","split","parseInt","matchedUsers","newUser","duplicateUser","Math","max","map","push","setItem","i","splice","then","response"],"mappings":"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","sourcesContent":["// array in local storage for registered users\r\nlet users = JSON.parse(localStorage.getItem(\"users\")) || [];\r\n\r\nexport function configureFakeBackend() {\r\n  let realFetch = window.fetch;\r\n  window.fetch = function (url, opts) {\r\n    return new Promise((resolve, reject) => {\r\n      // wrap in timeout to simulate server api call\r\n      setTimeout(() => {\r\n        // authenticate\r\n        if (url.endsWith(\"/users/authenticate\") && opts.method === \"POST\") {\r\n          // get parameters from post request\r\n          let params = JSON.parse(opts.body);\r\n\r\n          // find if any user matches login credentials\r\n          let filteredUsers = users.filter((user) => {\r\n            return (\r\n              user.username === params.username &&\r\n              user.password === params.password\r\n            );\r\n          });\r\n\r\n          if (filteredUsers.length) {\r\n            // if login details are valid return user details and fake jwt token\r\n            let user = filteredUsers[0];\r\n            let responseJson = {\r\n              id: user.id,\r\n              username: user.username,\r\n              firstName: user.firstName,\r\n              lastName: user.lastName,\r\n              token: \"fake-jwt-token\",\r\n            };\r\n            resolve({\r\n              ok: true,\r\n              text: () => Promise.resolve(JSON.stringify(responseJson)),\r\n            });\r\n          } else {\r\n            // else return error\r\n            reject(\"Username or password is incorrect\");\r\n          }\r\n\r\n          return;\r\n        }\r\n\r\n        // get users\r\n        if (url.endsWith(\"/users\") && opts.method === \"GET\") {\r\n          // check for fake auth token in header and return users if valid, this security is implemented server side in a real application\r\n          if (\r\n            opts.headers &&\r\n            opts.headers.Authorization === \"Bearer fake-jwt-token\"\r\n          ) {\r\n            resolve({\r\n              ok: true,\r\n              text: () => Promise.resolve(JSON.stringify(users)),\r\n            });\r\n          } else {\r\n            // return 401 not authorised if token is null or invalid\r\n            reject(\"Unauthorised\");\r\n          }\r\n\r\n          return;\r\n        }\r\n\r\n        // get user by id\r\n        if (url.match(/\\/users\\/\\d+$/) && opts.method === \"GET\") {\r\n          // check for fake auth token in header and return user if valid, this security is implemented server side in a real application\r\n          if (\r\n            opts.headers &&\r\n            opts.headers.Authorization === \"Bearer fake-jwt-token\"\r\n          ) {\r\n            // find user by id in users array\r\n            let urlParts = url.split(\"/\");\r\n            let id = parseInt(urlParts[urlParts.length - 1]);\r\n            let matchedUsers = users.filter((user) => {\r\n              return user.id === id;\r\n            });\r\n            let user = matchedUsers.length ? matchedUsers[0] : null;\r\n\r\n            // respond 200 OK with user\r\n            resolve({ ok: true, text: () => JSON.stringify(user) });\r\n          } else {\r\n            // return 401 not authorised if token is null or invalid\r\n            reject(\"Unauthorised\");\r\n          }\r\n\r\n          return;\r\n        }\r\n\r\n        // register user\r\n        if (url.endsWith(\"/users/register\") && opts.method === \"POST\") {\r\n          // get new user object from post body\r\n          let newUser = JSON.parse(opts.body);\r\n\r\n          // validation\r\n          let duplicateUser = users.filter((user) => {\r\n            return user.username === newUser.username;\r\n          }).length;\r\n          if (duplicateUser) {\r\n            reject('Username \"' + newUser.username + '\" is already taken');\r\n            return;\r\n          }\r\n\r\n          // save new user\r\n          newUser.id = users.length\r\n            ? Math.max(...users.map((user) => user.id)) + 1\r\n            : 1;\r\n          users.push(newUser);\r\n          localStorage.setItem(\"users\", JSON.stringify(users));\r\n\r\n          // respond 200 OK\r\n          resolve({ ok: true, text: () => Promise.resolve() });\r\n\r\n          return;\r\n        }\r\n\r\n        // delete user\r\n        if (url.match(/\\/users\\/\\d+$/) && opts.method === \"DELETE\") {\r\n          // check for fake auth token in header and return user if valid, this security is implemented server side in a real application\r\n          if (\r\n            opts.headers &&\r\n            opts.headers.Authorization === \"Bearer fake-jwt-token\"\r\n          ) {\r\n            // find user by id in users array\r\n            let urlParts = url.split(\"/\");\r\n            let id = parseInt(urlParts[urlParts.length - 1]);\r\n            for (let i = 0; i < users.length; i++) {\r\n              let user = users[i];\r\n              if (user.id === id) {\r\n                // delete user\r\n                users.splice(i, 1);\r\n                localStorage.setItem(\"users\", JSON.stringify(users));\r\n                break;\r\n              }\r\n            }\r\n\r\n            // respond 200 OK\r\n            resolve({ ok: true, text: () => Promise.resolve() });\r\n          } else {\r\n            // return 401 not authorised if token is null or invalid\r\n            reject(\"Unauthorised\");\r\n          }\r\n\r\n          return;\r\n        }\r\n\r\n        // pass through any requests not handled above\r\n        realFetch(url, opts).then((response) => resolve(response));\r\n      }, 500);\r\n    });\r\n  };\r\n}\r\n"]},"metadata":{},"sourceType":"module"}